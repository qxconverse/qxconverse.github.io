<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>qxconverse</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="qxconverse">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="qxconverse">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="qxconverse">
  
    <link rel="alternate" href="/atom.xml" title="qxconverse" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">qxconverse</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-大型网站系统的特点" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/12/大型网站系统的特点/" class="article-date">
  <time datetime="2018-04-12T12:12:00.000Z" itemprop="datePublished">2018-04-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/分布式系统/">分布式系统</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/12/大型网站系统的特点/">大型网站系统的特点</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>以下内容来自牛客网：</strong></p>
<h3 id="大型网站系统的特点"><a href="#大型网站系统的特点" class="headerlink" title="大型网站系统的特点"></a>大型网站系统的特点</h3><p><strong>高并发，大流量</strong></p>
<p>需要面对高并发用户，大流量访问。Google 日均 PV 35 亿，日 IP 访问数 3 亿；腾讯 QQ 的最大在线用户数 1.4 亿（2011年数据）。</p>
<p><strong>高可用</strong></p>
<p>系统 7 x 24 小时不间断服务。</p>
<p><strong>海量数据</strong></p>
<p>需要存储、管理海量数据，需要使用大量服务器。Facebook 每周上传的照片数量接近 10 亿，百度收录的网页数目有数百亿，Google 有近百万台服务器为全球用户提供服务。</p>
<p><strong>用户分布广泛，网络情况复杂</strong></p>
<p>许多大型互联网站都是为全球用户提供服务的，用户分布范围广，各地网络情况千差万别。在国内，还有各个运营商网络互通难的问题。</p>
<p><strong>安全环境恶劣</strong></p>
<p>由于互联网的开放性，使得互联网站更容易受到攻击，大型网站几乎每天都会被黑客攻击。</p>
<p><strong>需求快速变更，发布频繁</strong></p>
<p>和传统软件的版本发布频率不同，互联网产品为快速适应市场，满足用户需求，其产品发布频率极高。一般大型网站的产品每周都有新版本发布上线，中小型网站的发布更频繁，有时候一天会发布几十次。</p>
<p><strong>渐进式发展</strong></p>
<p>几乎所有的大型互联网网站都是从一个小网站开始，渐进地发展起来的。Facebook 是扎克伯格同学在哈佛大学的宿舍里开发的；Google 的第一台服务器部署在斯坦福大学的实验室；阿里巴巴是在马云家的客厅诞生的。好的互联网产品都是慢慢运营出来的，不是一开始就开发好的，这也正好与网站架构的发展演化过程对应。</p>
<h3 id="大型网站架构演化发展历程"><a href="#大型网站架构演化发展历程" class="headerlink" title="大型网站架构演化发展历程"></a>大型网站架构演化发展历程</h3><p>大型网站的技术挑战主要来自于庞大的用户，高并发的访问和海量的数据，任何简单的业务一旦需要处理数以 P 计的数据和面对数以亿计的用户，问题就会变得很棘手。大型网站架构主要解决这类问题。</p>
<p><strong>初始阶段的网站架构</strong></p>
<p>大型网站都是从小型网站发展而来，网站架构也是一样，是从小型网站架构逐步演化而来。小型网站最开始没有太多人访问，只需要一台服务器就绰绰有余，这时的网站架构如下图所示：<br><img src="http://img.blog.csdn.net/20180412200419145?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXhjb252ZXJzZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>应用程序、数据库、文件等所有资源都在一台服务器上。</p>
<p><strong>应用服务和数据服务分离</strong></p>
<p>随着网站业务的发展，一台服务器逐渐不能满足需求：越来越多的用户访问导致性能越来越差，越来越多的数据导致存储空间不足。这时就需要将应用和数据分离。应用和数据分离后整个网站使用3台服务器：应用服务器、文件服务器和数据库服务器。这 3 台服务器对硬件资源的要求各不相同：</p>
<blockquote>
<p>应用服务器需要处理大量的业务逻辑，因此需要更快更强大的CPU；</p>
<p>数据库服务器需要快速磁盘检索和数据缓存，因此需要更快的磁盘和更大的内存；</p>
<p>文件服务器需要存储大量用户上传的文件，因此需要更大的硬盘。</p>
</blockquote>
<p>此时，网站系统的架构如下图所示：</p>
<p><img src="http://img.blog.csdn.net/20180412200441826?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXhjb252ZXJzZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>应用和数据分离后，不同特性的服务器承担不同的服务角色，网站的并发处理能力和数据存储空间得到了很大改善，支持网站业务进一步发展。但是随着用户逐渐增多，网站又一次面临挑战：数据库压力太大导致访问延迟，进而影响整个网站的性能，用户体验受到影响。这时需要对网站架构进一步优化。</p>
<p><strong>使用缓存改善网站性能</strong></p>
<p>网站访问的特点和现实世界的财富分配一样遵循二八定律：80% 的业务访问集中在20% 的数据上。既然大部分业务访问集中在一小部分数据上，那么如果把这一小部分数据缓存在内存中，就可以减少数据库的访问压力，提高整个网站的数据访问速度，改善数据库的写入性能了。 网站使用的缓存可以分为两种：缓存在应用服务器上的本地缓存和缓存在专门的分布式缓存服务器上的远程缓存。</p>
<blockquote>
<p>本地缓存的访问速度更快一些，但是受应用服务器内存限制，其缓存数据量有限，而且会出现和应用程序争用内存的情况。</p>
<p>远程分布式缓存可以使用集群的方式，部署大内存的服务器作为专门的缓存服务器，可以在理论上做到不受内存容量限制的缓存服务。</p>
</blockquote>
<p><img src="http://img.blog.csdn.net/20180412200503812?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXhjb252ZXJzZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>使用缓存后，数据访问压力得到有效缓解，但是单一应用服务器能够处理的请求连接有限，在网站访问高峰期，应用服务器成为整个网站的瓶颈。</p>
<p><strong>使用应用服务器集群改善网站的并发处理能力</strong></p>
<p>使用集群是网站解决高并发、海量数据问题的常用手段。当一台服务器的处理能力、存储空间不足时，不要企图去更换更强大的服务器，对大型网站而言，不管多么强大的服务器，都满足不了网站持续增长的业务需求。这种情况下，更恰当的做法是增加一台服务器分担原有服务器的访问及存储压力。 对网站架构而言，只要能通过增加一台服务器的方式改善负载压力，就可以以同样的方式持续增加服务器不断改善系统性能，从而实现系统的可伸缩性。应用服务器实现集群是网站可伸缩架构设计中较为简单成熟的一种，如下图所示：</p>
<p><img src="http://img.blog.csdn.net/20180412200525420?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXhjb252ZXJzZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>通过负载均衡调度服务器，可以将来自用户浏览器的访问请求分发到应用服务器集群中的任何一台服务器上，如果有更多用户，就在集群中加入更多的应用服务器，使应用服务器的压力不再成为整个网站的瓶颈。</p>
<p><strong>数据库读写分离</strong></p>
<p>网站在使用缓存后，使对大部分数据读操作访问都可以不通过数据库就能完成，但是仍有一部分读操作（缓存访问不命中、缓存过期）和全部的写操作都需要访问数据库，在网站的用户达到一定规模后，数据库因为负载压力过高而成为网站的瓶颈。 目前大部分的主流数据库都提供主从热备功能，通过配置两台数据库主从关系，可以将一台数据库服务器的数据更新同步到另一台服务器上。网站利用数据库的这一功能，实现数据库读写分离，从而改善数据库负载压力。如下图所示：</p>
<p><img src="http://img.blog.csdn.net/20180412200534822?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXhjb252ZXJzZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>应用服务器在写数据的时候，访问主数据库，主数据库通过主从复制机制将数据更新同步到从数据库，这样当应用服务器读数据的时候，就可以通过从数据库获得数据。为了便于应用程序访问读写分离后的数据库，通常在应用服务器端使用专门的数据访问模块，使数据库读写分离对应用透明。</p>
<p><strong>使用反向代理和 CDN 加速网站响应</strong></p>
<p>随着网站业务不断发展，用户规模越来越大，由于中国复杂的网络环境，不同地区的用户访问网站时，速度差别也极大。有研究表明，网站访问延迟和用户流失率正相关，网站访问越慢，用户越容易失去耐心而离开。为了提供更好的用户体验，留住用户，网站需要加速网站访问速度。主要手段有使用 CDN 和方向代理。如下图所示：</p>
<p><img src="http://img.blog.csdn.net/20180412200546048?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXhjb252ZXJzZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>CDN 和反向代理的基本原理都是缓存。</p>
<blockquote>
<p>CDN 部署在网络提供商的机房，使用户在请求网站服务时，可以从距离自己最近的网络提供商机房获取数据</p>
<p>反向代理则部署在网站的中心机房，当用户请求到达中心机房后，首先访问的服务器是反向代理服务器，如果反向代理服务器中缓存着用户请求的资源，就将其直接返回给用户</p>
</blockquote>
<p>使用 CDN 和反向代理的目的都是尽早返回数据给用户，一方面加快用户访问速度，另一方面也减轻后端服务器的负载压力。</p>
<p><strong>使用分布式文件系统和分布式数据库系统</strong></p>
<p>任何强大的单一服务器都满足不了大型网站持续增长的业务需求。数据库经过读写分离后，从一台服务器拆分成两台服务器，但是随着网站业务的发展依然不能满足需求，这时需要使用分布式数据库。文件系统也一样，需要使用分布式文件系统。如下图所示：</p>
<p><img src="http://img.blog.csdn.net/20180412200555005?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXhjb252ZXJzZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>分布式数据库是网站数据库拆分的最后手段，只有在单表数据规模非常庞大的时候才使用。不到不得已时，网站更常用的数据库拆分手段是业务分库，将不同业务的数据部署在不同的物理服务器上。</p>
<p><strong>使用 NoSQL 和搜索引擎</strong></p>
<p>随着网站业务越来越复杂，对数据存储和检索的需求也越来越复杂，网站需要采用一些非关系数据库技术如 NoSQL 和非数据库查询技术如搜索引擎。如下图所示：</p>
<p><img src="http://img.blog.csdn.net/20180412200604598?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXhjb252ZXJzZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>NoSQL 和搜索引擎都是源自互联网的技术手段，对可伸缩的分布式特性具有更好的支持。应用服务器则通过一个统一数据访问模块访问各种数据，减轻应用程序管理诸多数据源的麻烦。</p>
<p><strong>业务拆分</strong></p>
<p>大型网站为了应对日益复杂的业务场景，通过使用分而治之的手段将整个网站业务分成不同的产品线。如大型购物交易网站都会将首页、商铺、订单、买家、卖家等拆分成不同的产品线，分归不同的业务团队负责。</p>
<p>具体到技术上，也会根据产品线划分，将一个网站拆分成许多不同的应用，每个应用独立部署。应用之间可以通过一个超链接建立关系（在首页上的导航链接每个都指向不同的应用地址），也可以通过消息队列进行数据分发，当然最多的还是通过访问同一个数据存储系统来构成一个关联的完整系统，如下图所示：</p>
<p><img src="http://img.blog.csdn.net/20180412200612883?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXhjb252ZXJzZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p><strong>分布式服务</strong></p>
<p>随着业务拆分越来越小，存储系统越来越庞大，应用系统的整体复杂度呈指数级增加，部署维护越来越困难。由于所有应用要和所有数据库系统连接，在数万台服务器规模的网站中，这些连接的数目是服务器规模的平方，导致数据库连接资源不足，拒绝服务。</p>
<p>既然每一个应用系统都需要执行许多相同的业务操作，比如用户管理、商品管理等，那么可以将这些共用的业务提取出来，独立部署。由这些可复用的业务连接数据库，提供共用业务服务，而应用系统只需要管理用户界面，通过分布式服务调用共用业务服务完成具体业务操作。如下图所示：</p>
<p><img src="http://img.blog.csdn.net/20180412200620439?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXhjb252ZXJzZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>大型网站的架构演化到这里，基本上大多数的技术问题都得以解决，诸如跨数据中心的实时数据同步和具体网站业务相关的问题也都可以通过组合改进现有技术架构解决。关于分布式的内容，可以继续看分布式系列文章。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/12/大型网站系统的特点/" data-id="cjov8y3ot000v4uniklkobyub" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-关于回溯法在排列和组合中的应用总结" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/10/关于回溯法在排列和组合中的应用总结/" class="article-date">
  <time datetime="2018-04-10T06:34:00.000Z" itemprop="datePublished">2018-04-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/算法与数据结构/">算法与数据结构</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/10/关于回溯法在排列和组合中的应用总结/">关于回溯法在排列和组合中的应用总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="关于回溯法在排列和组合中的应用总结"><a href="#关于回溯法在排列和组合中的应用总结" class="headerlink" title="关于回溯法在排列和组合中的应用总结"></a>关于回溯法在排列和组合中的应用总结</h4><p>下面是一段leetcode讨论区的原话：</p>
<blockquote>
<p>Backtracking can be solved always as follows:</p>
<p>Pick a starting point.<br>while(Problem is not solved)<br>    For each path from the starting point.<br>        check if selected path is safe, if yes select it<br>        and make recursive call to rest of the problem<br>        before which undo the current move.<br>    End For<br>If none of the move works out, return false, NO SOLUTON.</p>
</blockquote>
<p>数组中的元素不重复</p>
<p>比如：[1,2,3,4]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当使用额外的空间来存放时</span></span><br><span class="line"><span class="comment">//而且要检验元素是否用过</span></span><br><span class="line"><span class="comment">//     vector&lt;vector&lt;int&gt;&gt; res;</span></span><br><span class="line"><span class="comment">//     vector&lt;bool&gt; used;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     void doPermutation(vector&lt;int&gt;&amp; nums, int index, vector&lt;int&gt;&amp; c)&#123;</span></span><br><span class="line"><span class="comment">//         if (c.size() == nums.size()) &#123;</span></span><br><span class="line"><span class="comment">//             res.push_back(c);</span></span><br><span class="line"><span class="comment">//             return;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//每次从0开始遍历</span></span><br><span class="line"><span class="comment">//         for (int i = 0; i &lt; nums.size(); ++i) &#123;</span></span><br><span class="line"><span class="comment">//             if (!used[i]) &#123;</span></span><br><span class="line"><span class="comment">//                 used[i] = true;</span></span><br><span class="line"><span class="comment">//                 c.push_back(nums[i]);</span></span><br><span class="line"><span class="comment">//                 doPermutation(nums, index + 1, c);</span></span><br><span class="line"><span class="comment">//                 c.pop_back();</span></span><br><span class="line"><span class="comment">//                 used[i] = false;</span></span><br><span class="line"><span class="comment">//             &#125;</span></span><br><span class="line"><span class="comment">//         &#125; </span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123;</span></span><br><span class="line"><span class="comment">//         res.clear();</span></span><br><span class="line"><span class="comment">//         used = vector&lt;bool&gt;(nums.size(), false);</span></span><br><span class="line"><span class="comment">//         vector&lt;int&gt; temp;</span></span><br><span class="line"><span class="comment">//         doPermutation(nums, 0, temp);</span></span><br><span class="line"><span class="comment">//         return res;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//不使用额外的空间，直接通过交换的方法。不过这个时候</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doPermute</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index == nums.size() - <span class="number">1</span>) &#123;</span><br><span class="line">            res.push_back(nums);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//每次从index的位置开始</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; nums.size(); ++i) &#123;</span><br><span class="line">            swap(nums[i], nums[index]);</span><br><span class="line">            doPermute(nums, index + <span class="number">1</span>);</span><br><span class="line">            swap(nums[i], nums[index]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; permute(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        doPermute(nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>元素中有重复的，比如[1,1,2]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此版本为交换版本，不需要额外的空间</span></span><br><span class="line"><span class="comment">//     vector&lt;vector&lt;int&gt;&gt; res;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//     bool checkSame(vector&lt;int&gt;&amp; num, int start, int end, int target) &#123;  </span></span><br><span class="line"><span class="comment">//         for(int i = start; i &lt;= end; ++i) &#123;  </span></span><br><span class="line"><span class="comment">//             if (num[i] == num[target])  </span></span><br><span class="line"><span class="comment">//                 return false;  </span></span><br><span class="line"><span class="comment">//         &#125;  </span></span><br><span class="line"><span class="comment">//         return true;  </span></span><br><span class="line"><span class="comment">//     &#125;  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     void doPermuteUnique(vector&lt;int&gt;&amp; nums, int index) &#123;</span></span><br><span class="line"><span class="comment">//         if (index == nums.size() - 1) &#123;</span></span><br><span class="line"><span class="comment">//             res.push_back(nums);</span></span><br><span class="line"><span class="comment">//             return;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//         for (int i = index; i &lt; nums.size(); ++i) &#123;</span></span><br><span class="line"><span class="comment">//             if (!checkSame(nums, index, i - 1, i)) &#123;</span></span><br><span class="line"><span class="comment">//                 continue;</span></span><br><span class="line"><span class="comment">//             &#125;</span></span><br><span class="line"><span class="comment">//             swap(nums[i], nums[index]);</span></span><br><span class="line"><span class="comment">//             doPermuteUnique(nums, index + 1);</span></span><br><span class="line"><span class="comment">//             swap(nums[i], nums[index]);</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//     vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) &#123;</span></span><br><span class="line"><span class="comment">//         doPermuteUnique(nums, 0);</span></span><br><span class="line"><span class="comment">//         return res;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//需要额外的空间</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; used;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doPermuteUnique</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> index, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; temp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (temp.size() == nums.size()) &#123;</span><br><span class="line">            res.push_back(temp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//每次从0开始遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!used[i]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>] &amp;&amp; !used[i<span class="number">-1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                used[i] = <span class="literal">true</span>;</span><br><span class="line">                temp.push_back(nums[i]);</span><br><span class="line">                doPermuteUnique(nums, index + <span class="number">1</span>, temp);</span><br><span class="line">                temp.pop_back();</span><br><span class="line">                used[i] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; permuteUnique(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">        used = <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(nums.size(), <span class="literal">false</span>);</span><br><span class="line">        <span class="comment">//数组要事先排好序</span></span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        doPermuteUnique(nums, <span class="number">0</span>, temp);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>组合问题</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span>    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//从start位置开始。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doCombination</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> start, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (c.size() == k) &#123;</span><br><span class="line">            res.push_back(c);</span><br><span class="line">            <span class="keyword">return</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= n - (k - c.size()) + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            c.push_back(i);</span><br><span class="line">            <span class="comment">//到下一个位置</span></span><br><span class="line">            doCombination(n, k, i + <span class="number">1</span>, c);</span><br><span class="line">            c.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;     </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">        doCombination(n, k, <span class="number">1</span>, temp);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这是在无重复数字的数组中找数字，可以重复选取某个数字，要求和为某个目标值。</p>
<p>For example, given candidate set <code>[2, 3, 6, 7]</code> and target <code>7</code>,<br>A solution set is: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [7],</span><br><span class="line">  [2, 2, 3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//相当于有放回地取数字</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doCombinationSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> start, <span class="keyword">int</span> curSum, <span class="keyword">int</span> target, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; temp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (curSum == target) &#123;</span><br><span class="line">            res.push_back(temp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (curSum &gt; target) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; candidates.size(); ++i)&#123;</span><br><span class="line">            temp.push_back(candidates[i]);</span><br><span class="line">            <span class="comment">//可以重复选取，故还是i</span></span><br><span class="line">            doCombinationSum(candidates, i, curSum + candidates[i], target, temp);</span><br><span class="line">            temp.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; combinationSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">        doCombinationSum(candidates, <span class="number">0</span>, <span class="number">0</span>, target, temp);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这是在有重复数字的数组中找数字，不能重复选取某个数字，要求和为某个目标值。</p>
<p>For example, given candidate set <code>[10, 1, 2, 7, 6, 1, 5]</code> and target <code>8</code>,<br>A solution set is: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [1, 7],</span><br><span class="line">  [1, 2, 5],</span><br><span class="line">  [2, 6],</span><br><span class="line">  [1, 1, 6]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span>    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; used;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//相当于无放回地取数字</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doCombinationSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> start, <span class="keyword">int</span> curSum, <span class="keyword">int</span> target, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; temp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (curSum == target) &#123;</span><br><span class="line">            res.push_back(temp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (curSum &gt; target) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; candidates.size(); ++i)&#123;</span><br><span class="line">            <span class="comment">//每次遍历的时候，要看前面的数字是否等于后面的，这样就不会有重复的了。</span></span><br><span class="line">            <span class="keyword">if</span> (i != start &amp;&amp; candidates[i] == candidates[i<span class="number">-1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!used[i]) &#123;</span><br><span class="line">                used[i] = <span class="literal">true</span>;</span><br><span class="line">                temp.push_back(candidates[i]);</span><br><span class="line">                <span class="comment">//改成i+1体现在无放回，即不能再从它开始了</span></span><br><span class="line">                doCombinationSum(candidates, i + <span class="number">1</span>, curSum + candidates[i], target, temp);</span><br><span class="line">                temp.pop_back();</span><br><span class="line">                used[i] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:   </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; combinationSum2(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">        <span class="comment">//要先排序</span></span><br><span class="line">        sort(candidates.begin(), candidates.end());</span><br><span class="line">        used = <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(candidates.size(), <span class="literal">false</span>);</span><br><span class="line">        doCombinationSum(candidates, <span class="number">0</span>, <span class="number">0</span>, target, temp);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/10/关于回溯法在排列和组合中的应用总结/" data-id="cjov8y3op000o4uniy2yl5vkt" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-virtualFunction" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/10/virtualFunction/" class="article-date">
  <time datetime="2018-04-10T06:32:12.000Z" itemprop="datePublished">2018-04-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/C/">C++</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/10/virtualFunction/">关于C++中的析构函数</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="关于析构函数"><a href="#关于析构函数" class="headerlink" title="关于析构函数"></a>关于析构函数</h4><p>遇到跟析构函数相关的题目，总是做错。现在总结如下，对于下面的一段代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Base()&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base cons"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        m_int = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     ~Base()&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base des"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//~Base()&#123;&#125;</span></span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base foo"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_int;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dervid</span> :</span><span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Dervid()&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Dervid cons"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        str = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">32</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    ~Dervid()&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Dervid des"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span> (str) <span class="keyword">delete</span>[] str;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Dervid foo"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> *str;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Base *a = <span class="keyword">new</span> Dervid(); <span class="comment">//如果foo不设置为virtual，那么调用的是Base的；如果加上virtual，那么就是调用Dervid的</span></span><br><span class="line">a-&gt;foo();</span><br><span class="line"><span class="keyword">delete</span> a; <span class="comment">//不加delete就不会执行析构函数</span></span><br></pre></td></tr></table></figure>
<p>总结如下：</p>
<p><strong>当父类指针由子类生成时。如果函数为虚函数，则调用子类的方法；否则调用父类的方法。</strong></p>
<p><strong>如果父类析构函数为虚函数时，则在delete时，会先后调用子类和父类的析构函数；否则只调用父类的析构函数</strong></p>
<p>而对于非指针或引用的情况。父类对象由子类生成。则不会有任何区别。</p>
<table>
<thead>
<tr>
<th></th>
<th>virtual ~</th>
<th>~</th>
</tr>
</thead>
<tbody>
<tr>
<td>virtual foo</td>
<td>Base cons</td>
<td>Base cons</td>
</tr>
<tr>
<td></td>
<td>Dervid cons</td>
<td>Dervid cons</td>
</tr>
<tr>
<td></td>
<td><strong>Dervid foo</strong></td>
<td><strong>Dervid foo</strong></td>
</tr>
<tr>
<td></td>
<td><em>Dervid des</em></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Base des</td>
<td>Base des</td>
</tr>
<tr>
<td>foo</td>
<td>Base cons</td>
<td>Base cons</td>
</tr>
<tr>
<td></td>
<td>Dervid cons</td>
<td>Dervid cons</td>
</tr>
<tr>
<td></td>
<td><strong>Base foo</strong></td>
<td><strong>Base foo</strong></td>
</tr>
<tr>
<td></td>
<td><em>Dervid des</em></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Base des</td>
<td>Base des</td>
</tr>
</tbody>
</table>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//---------------------------------------</span></span><br><span class="line">Base b = Dervid();<span class="comment">//不管foo是不是virtual，都是Base的。不过在输出Base foo之前，还执行了Dervid的析构函数</span></span><br><span class="line">b.foo();<span class="comment">//而且不管Base是不是virtual析构，都要先执行Dervid的析构，然后执行Base的析构</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对于上面的四种情况，都是如下的输出</span></span><br><span class="line">Base cons</span><br><span class="line">Dervid cons</span><br><span class="line">Dervid des <span class="comment">//都要先执行Dervid的析构</span></span><br><span class="line">Base des <span class="comment">//然后执行Base的析构</span></span><br><span class="line">Base foo <span class="comment">//都是Base的</span></span><br><span class="line">Base des</span><br><span class="line"></span><br><span class="line"><span class="comment">//---------------------------------------</span></span><br><span class="line">Dervid b = Dervid();</span><br><span class="line">b.foo();</span><br><span class="line"></span><br><span class="line">Base cons</span><br><span class="line">Dervid cons</span><br><span class="line">Dervid foo</span><br><span class="line">Dervid des</span><br><span class="line">Base des</span><br><span class="line"></span><br><span class="line"><span class="comment">//---------------------------------------</span></span><br><span class="line">Base b = Base();</span><br><span class="line">b.foo();</span><br><span class="line"></span><br><span class="line">Base cons</span><br><span class="line">Base foo</span><br><span class="line">Base des</span><br><span class="line"></span><br><span class="line"><span class="comment">//---------------------------------------</span></span><br><span class="line">Base *a = <span class="keyword">new</span> Base();<span class="comment">//不管foo是不是virtual，都是Base的  </span></span><br><span class="line">a-&gt;foo();</span><br><span class="line"><span class="keyword">delete</span> a;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4种情况都是这样的</span></span><br><span class="line">Base cons</span><br><span class="line">Base foo</span><br><span class="line">Base des</span><br><span class="line"></span><br><span class="line"><span class="comment">//---------------------------------------</span></span><br><span class="line">Dervid *a = <span class="keyword">new</span> Dervid();<span class="comment">//不管foo是不是virtual，都是Dervid的</span></span><br><span class="line">a-&gt;foo();</span><br><span class="line"><span class="keyword">delete</span> a;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4种情况都是这样的</span></span><br><span class="line">Base cons</span><br><span class="line">Dervid cons</span><br><span class="line">Dervid foo</span><br><span class="line">Dervid des</span><br><span class="line">Base des</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/10/virtualFunction/" data-id="cjov8y3ol000h4uniez9yuky0" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-计算机视觉特征提取与图像处理总结" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/06/计算机视觉特征提取与图像处理总结/" class="article-date">
  <time datetime="2018-04-06T08:33:43.000Z" itemprop="datePublished">2018-04-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CV/">CV</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/06/计算机视觉特征提取与图像处理总结/">计算机视觉特征提取与图像处理总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="计算机视觉特征提取与图像处理总结"><a href="#计算机视觉特征提取与图像处理总结" class="headerlink" title="计算机视觉特征提取与图像处理总结"></a>计算机视觉特征提取与图像处理总结</h3><p>关于经典的计算机视觉这一块，简单地总结一下，罗列一些知识点，方便以后的再学习或是查阅。之所以称它为经典的，主要是因为里面都是些传统的方法，相较于最近几年才发展起来的深度学习方法而言。</p>
<h4 id="1-绪论"><a href="#1-绪论" class="headerlink" title="1.绪论"></a>1.绪论</h4><h4 id="2-图像、采样、频域处理"><a href="#2-图像、采样、频域处理" class="headerlink" title="2.图像、采样、频域处理"></a>2.图像、采样、频域处理</h4><h4 id="2-1-灰度，颜色，分辨率，动态范围，存储等"><a href="#2-1-灰度，颜色，分辨率，动态范围，存储等" class="headerlink" title="2.1 灰度，颜色，分辨率，动态范围，存储等"></a>2.1 灰度，颜色，分辨率，动态范围，存储等</h4><p>关于采样，要先理解信号在频域中的解释，理解傅里叶变换。<br><strong>采样标准：为了从样本重构原信号，采样频率必须至少是被采样信号最大频率的两倍。</strong></p>
<h4 id="2-2-离散傅里叶变换，其特性"><a href="#2-2-离散傅里叶变换，其特性" class="headerlink" title="2.2 离散傅里叶变换，其特性"></a>2.2 离散傅里叶变换，其特性</h4><p>平移、旋转、尺度变化，频域叠加（线性）。</p>
<h4 id="2-3-除了傅里叶以外的其它变换"><a href="#2-3-除了傅里叶以外的其它变换" class="headerlink" title="2.3 除了傅里叶以外的其它变换"></a>2.3 除了傅里叶以外的其它变换</h4><p>离散余弦变换<br>离散Hartley变换<br>小波变换<br>Walsh变换</p>
<h4 id="2-4-滤波——频域特性的应用"><a href="#2-4-滤波——频域特性的应用" class="headerlink" title="2.4 滤波——频域特性的应用"></a>2.4 滤波——频域特性的应用</h4><h4 id="3-基本的图像处理运算"><a href="#3-基本的图像处理运算" class="headerlink" title="3.基本的图像处理运算"></a>3.基本的图像处理运算</h4><h4 id="3-1-直方图"><a href="#3-1-直方图" class="headerlink" title="3.1 直方图"></a>3.1 直方图</h4><h4 id="3-2-点运算"><a href="#3-2-点运算" class="headerlink" title="3.2 点运算"></a>3.2 点运算</h4><p>亮度映射：加法、反转、尺度变化、对数、指数。<br>亮度正规化，直方图均衡化，阈值处理和最优阈值处理。</p>
<h4 id="3-3-群运算"><a href="#3-3-群运算" class="headerlink" title="3.3 群运算"></a>3.3 群运算</h4><p>模板卷积（包括频域实现）。统计算子：直接平均，高斯滤波，中值滤波，众数（截断中值）滤波。<br>直接平均：可以去除大量的噪声，但是使特征边界模糊；<br>高斯滤波：保留更多特性，但是与直接平均相比，几乎没有优势（噪声不是高斯分布的）；<br>中值滤波：保留一些噪声，但是得到清晰的边界特征；<br>截断中值滤波：去除更多噪声，但也去除更多的图像细节。</p>
<p>opencv的常见滤波有：<br>归一化块滤波器 (Normalized Box Filter)<br>最简单的滤波器， 输出像素值是核窗口内像素值的 均值 ( 所有像素加权系数相等)<br>高斯滤波器 (Gaussian Filter)<br>最有用的滤波器 (尽管不是最快的)。 高斯滤波是将输入数组的每一个像素点与 高斯内核 卷积将卷积和当作输出像素值。<br>中值滤波器 (Median Filter)<br>中值滤波将图像的每个像素用邻域 (以当前像素为中心的正方形区域)像素的 中值 代替 。<br>双边滤波 (Bilateral Filter)<br>目前我们了解的滤波器都是为了 平滑 图像， 问题是有些时候这些滤波器不仅仅削弱了噪声， 连带着把边缘也给磨掉了。 为避免这样的情形 (至少在一定程度上 ), 我们可以使用双边滤波。<br>类似于高斯滤波器，双边滤波器也给每一个邻域像素分配一个加权系数。 这些加权系数包含两个部分, 第一部分加权方式与高斯滤波一样，第二部分的权重则取决于该邻域像素与当前像素的灰度差值。</p>
<p>图像平滑处理的各向异性扩散。<br>力场变换。<br>数学形态学：击中或未击中变换，腐蚀，膨胀（包括灰度算子：腐蚀算子，膨胀算子，开算子，闭算子等），明科夫斯基算子。</p>
<h4 id="4-低级特征提取（包括边缘检测）（边缘检测、角点检测、运动检测）"><a href="#4-低级特征提取（包括边缘检测）（边缘检测、角点检测、运动检测）" class="headerlink" title="4.低级特征提取（包括边缘检测）（边缘检测、角点检测、运动检测）"></a>4.低级特征提取（包括边缘检测）（边缘检测、角点检测、运动检测）</h4><h4 id="4-1-边缘检测"><a href="#4-1-边缘检测" class="headerlink" title="4.1 边缘检测"></a>4.1 边缘检测</h4><p>一阶边缘检测算子<br>差分运算、Roberts交叉算子、平滑处理、Prewitt、Sobel、Canny等算子。<br>二阶边缘检测算子<br>二阶差分、Laplacian算子、过零点检测；Marr-Hildreth算子、Laplacian of Gaussian，高斯差分，尺度空间。<br>其它的边缘检测算子：Spacek算子，Petrou算子、Susan算子。<br>所有边缘算子的结果都是用滞后阈值处理来实现的。<br>对于拥有很大噪声的图像，Canny算子、Spacek算子相较于其它的算子表现要好些。</p>
<h4 id="4-2-相位一致性"><a href="#4-2-相位一致性" class="headerlink" title="4.2 相位一致性"></a>4.2 相位一致性</h4><p>相位一致性方法是一个特征检测算子，主要有两个优点：</p>
<pre><code>1. 可以检测大范围的特征；
2. 对局部（和平滑）光照变化具有不变性。
</code></pre><p>频域分析；检测一连串特征；光度不变性，小波。</p>
<h4 id="4-3-定位特征提取（角点提取）"><a href="#4-3-定位特征提取（角点提取）" class="headerlink" title="4.3 定位特征提取（角点提取）"></a>4.3 定位特征提取（角点提取）</h4><p>平面曲率；角点；Moravec和Harris检测器；尺度空间。<br><strong>SIFT（尺度不变特征变换）</strong><br><strong>其具有尺度、旋转不变性。对光照变化也有一定的不变性。</strong></p>
<p>SIFT(Scale Invariant Feature Transform)特征对旋转、尺度缩放、亮度变化等保持不变性，是非常稳定的局部特征。<br>SIFT的主要思路：a)构造图像的尺度空间表示，b)在尺度空间中搜索图像的极值点，c)由极值点建立特征描述向量，d)用特征描述向量进行相似度匹配。<br>检测：通过图像与DOG算子卷积得到一幅二维图像在不同尺度下的尺度空间表示（即DOG图像）；然后通过每个像素点与其三维领域的临近点进行比较，找出DOG局部极值点作为初步的特征点；然后通过曲线拟合（临近信息插补）得到特征点的精确位置，同时也会舍弃那些不明显关键点和边缘响应；接下来利用特征点邻域像素的梯度分布来确定特征点的方向。每个特征点都包含三个信息$(x,y,σ,θ)$，即位置、尺度和方向。<br>描述：描述子将被用来作为目标匹配的依据，所以应具有较高的独特性以保证匹配率。特征描述大致包含三个步骤：1.旋转主方向，即将坐标轴旋转为关键点方向，以确保旋转不变性。2.然后在特征点对应的高斯图像上统计其16 $\times$ 16邻域内的方向梯度，将统计向量作为该点的sift描述子。3.特征向量的常规归一化，进一步去除光照变化等影响。<br>匹配：RANSAC(RANdom SAmple Consensus)方法是当前常用的一种特征点对的匹配算法，在OpenCV中我们可以使用暴力匹配（BruteForceMatcher）和FLANN（Fast Library for Approximate Nearest Neighbors，快速最近邻逼近搜索函数库）实现快速高效匹配。另外由于噪声等其他因素影响，有时次优匹配点可能和最优匹配点非常接近（接近0.8），实验证明舍弃这些点效果会更好。 </p>
<p>SURF（加速的鲁棒特征）。<br>显著性算子。</p>
<h4 id="4-4-描述图像运动"><a href="#4-4-描述图像运动" class="headerlink" title="4.4 描述图像运动"></a>4.4 描述图像运动</h4><p>差分检测；光流，孔径问题，平滑约束；微分方法；Horn and Schunk方法；相关性。</p>
<h4 id="5-形状匹配的特征提取"><a href="#5-形状匹配的特征提取" class="headerlink" title="5.形状匹配的特征提取"></a>5.形状匹配的特征提取</h4><h4 id="5-1-阈值处理和背景减法（差分）"><a href="#5-1-阈值处理和背景减法（差分）" class="headerlink" title="5.1 阈值处理和背景减法（差分）"></a>5.1 阈值处理和背景减法（差分）</h4><h4 id="5-2-模板匹配"><a href="#5-2-模板匹配" class="headerlink" title="5.2 模板匹配"></a>5.2 模板匹配</h4><p>直接实现和傅里叶实现。</p>
<h4 id="5-3-低级特征"><a href="#5-3-低级特征" class="headerlink" title="5.3 低级特征"></a>5.3 低级特征</h4><p>收集低级特征进行目标提取；基于频率的和基于部件的方法；检测测量值的分布。<br>小波和Haar小波；SIFT和SURF描述；以及方向梯度的直方图。</p>
<h4 id="5-4-霍夫变换"><a href="#5-4-霍夫变换" class="headerlink" title="5.4 霍夫变换"></a>5.4 霍夫变换</h4><p>通过匹配进行特征提取；利用霍夫变换检测二次曲线，以及任意形状；不变性表达。</p>
<h4 id="6-高级特征提取：可变形形状分析"><a href="#6-高级特征提取：可变形形状分析" class="headerlink" title="6.高级特征提取：可变形形状分析"></a>6.高级特征提取：可变形形状分析</h4><p>不具备目标形状（即特征）模型的知识；形状未知或形状的波动无法参数化。</p>
<h4 id="6-1-可变形形状分析"><a href="#6-1-可变形形状分析" class="headerlink" title="6.1 可变形形状分析"></a>6.1 可变形形状分析</h4><p>可变形模板；能量最大化；基于部分的形状分析；</p>
<h4 id="6-2-主动轮廓和蛇模型"><a href="#6-2-主动轮廓和蛇模型" class="headerlink" title="6.2 主动轮廓和蛇模型"></a>6.2 主动轮廓和蛇模型</h4><p>曲线演变的能量最小化；贪心算法；Kass蛇模型。</p>
<h4 id="6-3-形状骨架化"><a href="#6-3-形状骨架化" class="headerlink" title="6.3 形状骨架化"></a>6.3 形状骨架化</h4><p>距离变换和形状骨架；平均轴变换；离散对称算子；对称点分布的证据累加。</p>
<h4 id="6-4-主动形状模型"><a href="#6-4-主动形状模型" class="headerlink" title="6.4 主动形状模型"></a>6.4 主动形状模型</h4><p>通过统计方法表达形状变化；利用特征提取获取形状变化。<br>主动形状模型；主动外观模型；主成分分析。</p>
<h4 id="7-目标描述"><a href="#7-目标描述" class="headerlink" title="7.目标描述"></a>7.目标描述</h4><h4 id="7-1-边界描述"><a href="#7-1-边界描述" class="headerlink" title="7.1 边界描述"></a>7.1 边界描述</h4><p>边界和区域，如何确定边界及其所界定的区域，如何形成区域描述及其必要的特性？<br>基本方法：链码。傅里叶描述符：离散近似；累积角函数和椭圆傅里叶描述符。</p>
<h4 id="7-2-区域描述符"><a href="#7-2-区域描述符" class="headerlink" title="7.2 区域描述符"></a>7.2 区域描述符</h4><p>如何描述形状的区域？<br>基本形状量度：面积；周长；紧凑度；分散性。<br>矩：基本矩；中心矩；不变矩；Zernike矩；特性及重构。</p>
<h4 id="8-纹理描述、分割和分类基础"><a href="#8-纹理描述、分割和分类基础" class="headerlink" title="8.纹理描述、分割和分类基础"></a>8.纹理描述、分割和分类基础</h4><h4 id="8-1-纹理描述"><a href="#8-1-纹理描述" class="headerlink" title="8.1 纹理描述"></a>8.1 纹理描述</h4><p>什么是图像纹理，如何确定几组数值来识别纹理？<br>特征提取：傅里叶变换，共生矩阵，区域；<br><strong>现代方法：局部二值模式（LPB）和均一LBP。</strong></p>
<p>LBP原理：LBP指局部二值模式，英文全称：Local Binary Pattern，是一种用来描述图像局部特征的算子，LBP特征具有灰度不变性和旋转不变性等显著优点。它是由T. Ojala, M.Pietikäinen, 和 D. Harwood 在1994年提出，由于LBP特征计算简单、效果较好，因此LBP特征在计算机视觉的许多领域都得到了广泛的应用，LBP特征比较出名的应用是用在人脸识别和目标检测中，在计算机视觉开源库OpenCV中有使用LBP特征进行人脸识别的接口，也有用LBP特征训练目标检测分类器的方法，Opencv实现了LBP特征的计算，但没有提供一个单独的计算LBP特征的接口。<br>原始的LBP算子定义在像素3 $\times$ 3的邻域内，以邻域中心像素为阈值，相邻的8个像素的灰度值与邻域中心的像素值进行比较，若周围像素大于中心像素值，则该像素点的位置被标记为1，否则为0。这样，3 $\times$ 3邻域内的8个点经过比较可产生8位二进制数，将这8位二进制数依次排列形成一个二进制数字，这个二进制数字就是中心像素的LBP值，LBP值共有28种可能，因此LBP值有256种。中心像素的LBP值反映了该像素周围区域的纹理信息。<br>备注：计算LBP特征的图像必须是灰度图，如果是彩色图，需要先转换成灰度图。 </p>
<p>特征描述：能量，熵，惯性。</p>
<h4 id="8-2-距离量度"><a href="#8-2-距离量度" class="headerlink" title="8.2 距离量度"></a>8.2 距离量度</h4><p>距离量度：Manhattan城区和欧式（L1/L2距离），Mahalanobis，Bhattacharyya和余弦；构造、可视化和混淆矩阵。</p>
<h4 id="8-3-纹理分类"><a href="#8-3-纹理分类" class="headerlink" title="8.3 纹理分类"></a>8.3 纹理分类</h4><p>如何将所得的数值与已知样本相联系？</p>
<p>k近邻法则，支持向量机及其它分类方法（与机器学习交叉的部分）。</p>
<h4 id="8-4-纹理分割"><a href="#8-4-纹理分割" class="headerlink" title="8.4 纹理分割"></a>8.4 纹理分割</h4><p>如何在图像范围内找出纹理区域？<br>卷积计算，平铺处理，阈值处理。</p>
<h4 id="9-运动对象的检测与描述"><a href="#9-运动对象的检测与描述" class="headerlink" title="9.运动对象的检测与描述"></a>9.运动对象的检测与描述</h4><h4 id="9-1-运动对象提取"><a href="#9-1-运动对象提取" class="headerlink" title="9.1 运动对象提取"></a>9.1 运动对象提取</h4><p>如何将运动对象从它们的背景中分离？<br>应用到背景图像估计的平均与中值滤波。通过减从背景分离。通过高斯混合与阈值化处理改善。<br>问题：颜色、光照和阴影。</p>
<h4 id="使用膨胀与腐蚀；开、闭运算。连通组件分析。"><a href="#使用膨胀与腐蚀；开、闭运算。连通组件分析。" class="headerlink" title="使用膨胀与腐蚀；开、闭运算。连通组件分析。"></a>使用膨胀与腐蚀；开、闭运算。连通组件分析。</h4><h4 id="9-2-运动对象跟踪"><a href="#9-2-运动对象跟踪" class="headerlink" title="9.2 运动对象跟踪"></a>9.2 运动对象跟踪</h4><p>跟踪过程中实现时域一致性。建模线性系统动力学。<br>通过局部搜索进行跟踪；Lucas-Kanade方法；Kalman滤波；多目标跟踪；特征点与背景减的比较；Camshift与Meanshift方法。对象检测跟踪。</p>
<h4 id="9-3-运动形状分析与描述"><a href="#9-3-运动形状分析与描述" class="headerlink" title="9.3 运动形状分析与描述"></a>9.3 运动形状分析与描述</h4><p>通过证据收集描述运动以及提取运动形状。添加速率与位移到形状描述；针对识别目的，描述运动目标。</p>
<p>opencv遍历像素的方式？<br>目前，OpenCV主要有三种逐像素遍历图像的方法。<br>经典的C风格运算符<code>[]</code>（指针）访问（高效的方式）<br>迭代法 The iterator (safe) method（迭代器方式）<br>通过相关返回值的On-the-fly地址计算（随机访问方式，利用at函数）<br>自带的LUT方式<br>LUT方式&gt;高效的方式&gt;迭代器的方式和随机访问的方式</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/06/计算机视觉特征提取与图像处理总结/" data-id="cjov8y3p000164uni9qhwub9f" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-用Caffe进行NRIQA实验记录" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/06/用Caffe进行NRIQA实验记录/" class="article-date">
  <time datetime="2018-04-06T08:33:43.000Z" itemprop="datePublished">2018-04-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/深度学习/">深度学习</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/06/用Caffe进行NRIQA实验记录/">用Caffe进行NRIQA实验记录</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>最近看了一篇关于NR IQA的论文，其使用的是CNN，在电脑上装好了caffe环境后，打算根据那篇论文做一次实验，以下记录实验步骤。</p>
<p>首先需要准备好Live数据库和论文中关于图像预处理的matlab代码，下图就是训练数据的预处理代码：</p>
<p><img src="http://img.blog.csdn.net/20180408221042073?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXhjb252ZXJzZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>而Live数据库文件结构如下：</p>
<p><img src="http://img.blog.csdn.net/20180408221100055?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXhjb252ZXJzZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>首先我拿<code>fastfading</code>文件夹里面的图像做实验，这是一种失真类型（distortion type），里面有145张（295）失真的图像，和29张原始图像，每张图像有5张不同强度的失真。看了下预处理的代码，首先执行<code>prep_training_data.m</code>代码。此代码的功能是将图像进行分块处理，每一张图像被分成很多3232大小的小块图像（patches），并进行局部正规化（Local Normalization）处理。最终生成<code>prepared_data</code>文件夹，里面共有174（包括参照图像）个子文件夹，每个子文件夹存放对应图像的小块图像。<br><img src="http://img.blog.csdn.net/20180408221134798?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXhjb252ZXJzZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br><img src="http://img.blog.csdn.net/20180408221152543?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXhjb252ZXJzZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p><img src="http://img.blog.csdn.net/20180408221217459?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXhjb252ZXJzZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p><img src="http://img.blog.csdn.net/20180408221227089?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXhjb252ZXJzZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<blockquote>
<p>Twenty-nine high-resolution 24-bits/pixel RGB color images (typically 768 X 512) were distorted using five distortion types: JPEG2000, JPEG, white noise in the RGB components, Gaussian blur, and transmission errors in the JPEG2000 bit stream using a fast-fading Rayleigh channel model. A database was derived from the 29 images such that each image had test versions with each distortion type, and for each distortion type the perceptual quality roughly covered the entire quality range. Observers were asked to provide their perception of quality on a continuous linear scale that was divided into five equal regions marked with adjectives Bad”,Poor”, Fair”,Good” and <code></code>Excellent”. About 20-29 human observers rated each image. Each distortion type was evaluated by different subjects in different experiments using the same equipment and viewing conditions. In this way a total of 982 images, out of which 203 were the reference images, were evaluated by human subjects in seven experiments. The raw scores for each subject were converted to difference scores (between the test and the reference) and then Z-scores and then scaled and shifted to the full range (1 to 100). Finally, a Difference Mean Opinion Score (DMOS) value for each distorted image was computed.</p>
<p>dmos=[dmos_jpeg2000(1:227) dmos_jpeg(1:233) white_noise(1:174) gaussian_blur(1:174) fast_fading(1:174)] where dmos_distortion(i) is the dmos value for image “distortion\imgi.bmp” where distortion can be one of the five described above. The values of dmos when corresponding orgs==1 are zero (they are reference images). Note that imperceptible loss of quality does not necessarily mean a dmos value of zero due to the nature of the score processing used.</p>
</blockquote>
<p><img src="http://img.blog.csdn.net/20180408221302667?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXhjb252ZXJzZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>接着将<code>dmos.mat</code>中的第809列到982列保存到<code>fastfading</code>文件夹里面，代码为：</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">save(<span class="string">'E:\DeepLearning\Live\fastfading\dmos_local.mat'</span>, <span class="string">'dmos_local_fastfading'</span>)</span><br></pre></td></tr></table></figure>
<p>接着开始运行<code>prep_scores_data.m</code>代码，生成训练验证集文件，这里设置得参数为100，所以得到了100个训练验证集数据。<br><img src="http://img.blog.csdn.net/20180408221335260?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXhjb252ZXJzZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br><img src="http://img.blog.csdn.net/20180408221359963?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXhjb252ZXJzZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>例如<code>scores_train_1.txt</code>这个文件大概就有50000行左右，因为生成的规则是：选取80%的图像（原始图像和失真图像）作为训练集，那么<code>fastfading</code>里面有174张图像，而每张图像大概被分成了380个左右的小块，那么就会有1740.8380，约52000行。而验证集为20%。<br><img src="http://img.blog.csdn.net/20180408221418460?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXhjb252ZXJzZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>到目前为止，图像与对应的评分就预处理完毕了，即已经获得了数据与标签，接下来就要用caffe来训练了。首先要生成lmdb格式的数据。<br><img src="http://img.blog.csdn.net/20180408221432826?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXhjb252ZXJzZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br><img src="http://img.blog.csdn.net/20180408221452319?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXhjb252ZXJzZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br><img src="http://img.blog.csdn.net/20180408221502854?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXhjb252ZXJzZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>生成训练集和测试集的lmdb格式的数据</p>
<p>生成训练集和测试集的lmdb格式的数据</p>
<p>生成好lmdb数据后就需要配置prototxt文件了。这里面需要修改很多，而且遇到了一些问题，比如在论文的实验代码中pooling用到了MIN，但是caffe源码里面并没有，后来才知道是他们自己添加到源码<code>pooling_layer.cpp</code>和对应的cuda文件里面的，其目录为：<code>(caffeRoot)\src\caffe\layers</code></p>
<p><img src="http://img.blog.csdn.net/20180408221520672?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXhjb252ZXJzZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br><img src="http://img.blog.csdn.net/20180408221533970?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXhjb252ZXJzZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br><img src="http://img.blog.csdn.net/20180408221542230?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXhjb252ZXJzZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>源码文件中被添加的部分</p>
<p>源码的<code>caffe.proto</code>里面的片段</p>
<p>论文的代码<code>caffe.proto</code>里面的片段</p>
<p>考虑到如果要用min池化类型的话，需要重新编译caffe源码，所以我暂且先用ave来代替这个。</p>
<p>第二个很大的问题是最后的loss方法，论文中用到的是SVRloss，而我看到源码里面并没有，于是查看到他们确实也单独写了一个<code>svr_loss_layer.cpp</code>在相应的目录下，即<code>(caffeRoot)\src\caffe\layers</code>，到这里我确实有点懵逼了，没办法，我暂且先用其它的loss方法代替，于是找到了一个L2范数的loss，即EuclideanLoss，其实他们的这个所谓的svr_loss很像L1范数，就是求差值的绝对值。。。<br><img src="http://img.blog.csdn.net/20180408221559875?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXhjb252ZXJzZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>论文中自己写的代码</p>
<p>最后终于训练起来了，等待中。。。<br><img src="http://img.blog.csdn.net/20180408221615632?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXhjb252ZXJzZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>明天早上来看吧。。。</p>
<p>看到结果感觉很奇怪，loss值很高，而且一直居高不下，很没有优化的痕迹。于是去测试了一下，发现结果loss都很高。于是就想能不能把这个评分问题看成分类问题，原始图像的评分都在0-100，于是我做了处理，取十位数作为得分，比如55分，就改成5，38分就改成3，以此类推。接着就再次生成lmdb数据，然后用LeNet跑了一下，发现分类的精确度才47%左右。。。效果不是很好。所以还应该把它当做回归的问题来做。</p>
<p>用LeNet模型来做分类，准确率只有47%左右<br><img src="http://img.blog.csdn.net/20180408221632121?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXhjb252ZXJzZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>然后，我就想会不会是代码的问题，因为论文中的代码改了很多，万一有些改动我没有发现，那也有可能导致结果不好，于是我就把它所有可能的改动给加了进去，比如加了svrloss那个cpp文件，最小池化的部分也加了，然后编译（对，又花了很久），然后训练，发现还是一样，loss值没有变，并没有得到权重优化。</p>
<p>没办法，我只能去研究一下测试结果，返现loss值恰好是主观评分的平方除以2，考虑到每次只测试一张图像，再分析源码，用的是EuclideanLoss，所以可以推断出网络算出来的得分为0….顿时崩溃。用SVRLoss，再加上最小池化，得出的结果也是类似。思考了很久，猜测是输出的权重可能是都是0，于是把caffemodel文件里面的权值用matlab显示出来，发现也不是0，这时想了想，既然不是权重的问题，也不是模型的问题，也不是代码的问题，那就只有可能是输入的原始数据的问题了，于是就把小块图像用matlab显示出来，发现像素值在0-255之间，但是论文中不是说正规化处理过了吗，值不应该这样啊。</p>
<p>于是在训练模型prototxt文件中的数据层里面加了一个除以256的操作，然后再训练，测试，居然可以了。虽然结果没有很好，但是至少上路了。而不是出现那种很恐怖的错误了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/06/用Caffe进行NRIQA实验记录/" data-id="cjov8y3ox00124uniasprako8" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-面试常见问题" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/28/面试常见问题/" class="article-date">
  <time datetime="2018-03-28T13:38:01.000Z" itemprop="datePublished">2018-03-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/面试/">面试</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/28/面试常见问题/">面试常见问题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="面试常见问题"><a href="#面试常见问题" class="headerlink" title="面试常见问题"></a>面试常见问题</h3><p>算法题常见的思路：</p>
<ol>
<li>用双指针（甚至多指针）（比如头尾逼近）</li>
<li>想到二分的思想</li>
<li>想到patition的思想（快排里的）</li>
<li>想到用空间换时间</li>
<li>想到用哈希table（比如用数组构造，或是调用unordered_set或unordered_map）</li>
<li>想到用查找表（比如map/set等一系列的）</li>
<li>想到用动态规划或贪心算法</li>
<li>想到用回朔法</li>
</ol>
<p>若结点的存储地址与其关键字值之间存在某种对应关系，则这种存储结构为散列存储。<br>散列存储：散列存储，又称hash存储，是一种力图将数据元素的存储位置与关键码之间建立确定对应关系的查找技术。<br>基本思想：由节点的关键码值决定节点的存储地址。散列技术除了可以用于查找外，还可以用于存储。</p>
<p>特点：<br>散列是数组存储方式的一种发展，相比数组，散列的数据访问速度要高于数组，因为可以依据存储数据的部分内容找到数据在数组中的存储位置，进而能够快速实现数据的访问，理想的散列访问速度是非常迅速的，而不像在数组中的遍历过程，采用存储数组中内容的部分元素作为映射函数的输入，映射函数的输出就是存储数据的位置，这样的访问速度就省去了遍历数组的实现，因此时间复杂度可以认为为O(1)，而数组遍历的时间复杂度为O(n)。</p>
<p>1.排序算法的思考方式</p>
<p><img src="http://img.blog.csdn.net/20180327172535147?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXhjb252ZXJzZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>SVM和Logistic回归的比较：（1）经典的SVM，直接输出类别，不给出后验概率；（2）Logistic回归，会给出属于哪一个类别的后验概率；（3）比较重点是二者目标函数的异同。</p>
<p>SVR回归区别于传统的回归，在计算模型输出和真实输出之前的差别时，可以容忍小部分的偏差\epsilon。</p>
<p>逻辑回归模型参数的求解，一般通过极大似然估计，也就得到了logloss。至于logloss，个人觉得有一个稍微有点物理意义的解释：可以把logloss分解成真实分布的熵+真实分布与预测分布的相对熵（KL散度），前半部分是固定的，所以最小化logloss相当于在最小化真实分布与预测分布之间的差异。</p>
<p>bagging是并行式集成学习方法的最著名的代表。</p>
<p>m个样本的数据集可放回随机取出一个样本放入采样集。m次采样中，含有m个样本的采样集。采样出T个含有m个训练样本的采样集。基于每一个采样集，训练出一个基学习器。再将这些结合起来。</p>
<p>与标准adaboost只适用于二分类任务不同，bagging能不经修改地用于多分类、回归等任务。</p>
<p>Bagging 是 Bootstrap Aggregating 的简称，意思就是再取样 (Bootstrap) 然后在每个样本上训练出来的模型取平均，所以是降低模型的 variance. Bagging 比如 Random Forest 这种先天并行的算法都有这个效果。</p>
<p>Boosting 则是迭代算法，每一次迭代都根据上一次迭代的预测结果对样本进行加权，所以随着迭代不断进行，误差会越来越小，所以模型的 bias 会不断降低。这种算法无法并行，例子比如 Adaptive Boosting.</p>
<p>1.总结极大似然估计和最大后验估计</p>
<p>2.朴素贝叶斯分类</p>
<p>3，线性回归</p>
<p>4，svr回归</p>
<p>5.pca，lpa</p>
<p>算法面试常问的问题：</p>
<p>1.服务器：Linux，shell</p>
<p>2.数据库，存储系统：数据库</p>
<p>3.C/C++代码功底</p>
<p>4.网络编程（计算机网络）</p>
<p>5.多线程、并发（操作系统）</p>
<p>6.云计算，分布式（重点）</p>
<p>7.机器学习、深度学习</p>
<p>8.python语言，opencv，计算机视觉</p>
<p>9.算法及数据结构</p>
<p>推荐算法熟悉么？答：只知道基于内容的推荐和协同过滤。你提到了关联规则， 关联规则具体你知道哪些算法？：Apriori和FP-Growth</p>
<p>k-means大概是怎么回事？答：最大化簇间距离，最小化簇内距离</p>
<p>银行家算法  </p>
<p>   死锁条件  </p>
<p>   计算机网络：（竟然还被问了网络。。。感觉自己只能一直说。。。对不起，这些事本科时学的，现在忘光了。。。但是面试官仿佛听不到一样一直往死里问我。。。T^T）  </p>
<p>   从上到下说出网络有哪些层，每层具体应用？  </p>
<p>   浏览器是哪一层的？  </p>
<p>   动态协议和静态协议有哪些？</p>
<p>数据结构：  </p>
<p>   1。最大子序列和：一串序列，找出和最大的子序列：用一个变量储存第i位之前最大的和，碰到新的数字进行相应的加减法， 一旦这个变量小于0就置为0。  </p>
<p>   2。平衡二叉树是怎么回事，介绍一下  </p>
<p>   3。链表中有环怎么找？两个指针  </p>
<p>   4。海量数据中找中位数（数据有100G,内存只有1G）：利用外部排序确定，或者可以用两个堆</p>
<p>对于海量数据的情况，一定要想到分治法，即不断地二分划分，这样的算法复杂度就是O(\log n)。而且还要想到用位来操作。很多算法问题也会用到。这是一个你在想不出用什么方法的时候最有可能利用的方法。</p>
<p>当然也要想到用桶排序。</p>
<p>SVM处理多分类问题<br>SVM是一个二分类器，处理多分类问题时，常用的策略有：“一对一”（One vs. One, 简称OvO）、“一对其余”（One vs. Rest, 简称OvR）和“多对多”（Many vs. Many，简称MvM）。<br>OvO：对于给定数据集D=(xi,yi),(x2,y2),…,(xm,ym),yi∈C1,C2,…,CN。OvO将这N个类别两两配对，从而产生N(N−1)/2 个二分类任务。测试阶段，新样本将同时提交给所有分类器，于是我们可得到N(N−1)/2 个分类结果，最终把被预测得最多的类别作为最终分类结果。<br>OvR：每次将一个类的样例作为正例，所有其他类的样例作为反例来训练N个分类器。在预测时选择置信度最大的类别作为分类结果。<br>MvM：每次将若干个类作为正类，若干个其他类作为反类。 </p>
<p>堆排序、快速排序、希尔排序、直接选择排序不是稳定的排序算法，而基数排序、冒泡排序、直接插入排序、折半插入排序、归并排序是稳定的排序算法。</p>
<ol>
<li><p>在每一个链表中取出第一个值，然后把它们放在一个大小为N的数组里，然后把这个数组当成heap建成小(大)根堆。此步骤的时间复杂度为<code>$O(N)$</code></p>
</li>
<li><p>取出堆中的最小值(也是数组的第一个值), 然后把该最小值所处的链表的下一个值放在数组的第一个位置。如果链表中有一个已经为空（元素已经都被取出），则改变heap的大小。此步骤的时间复杂度为<code>$O(logN)$</code>.</p>
</li>
<li><p>不断的重复步骤二，直到所有的链表都为空。</p>
</li>
</ol>
<p>最终的时间复杂度为：<code>$(O(N)+O(N*logN))*M$</code></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/28/面试常见问题/" data-id="cjov8y3p2001b4univ3s11txu" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Python中的装饰器" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/19/Python中的装饰器/" class="article-date">
  <time datetime="2018-03-19T13:18:19.000Z" itemprop="datePublished">2018-03-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Python/">Python</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/19/Python中的装饰器/">Python中的装饰器</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Python中的装饰器"><a href="#Python中的装饰器" class="headerlink" title="Python中的装饰器"></a>Python中的装饰器</h3><p>在Python中，装饰器本质上是一个Python函数，它可以让其他函数在不需要做任何代码变动的前提下增加额外功能，装饰器的返回值也是一个函数对象。它经常用于有切面需求的场景，比如：插入日志、性能测试、事务处理、缓存、权限校验等场景。装饰器是解决这类问题的绝佳设计，有了装饰器，我们就可以抽离出大量与函数功能本身无关的雷同代码并继续重用。概括的讲，装饰器的作用就是<strong>为已经存在的函数或对象添加额外的功能</strong>。</p>
<p>下面是一个最简单的不带参数的装饰器，其输入就是一个函数名。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug</span><span class="params">(func)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(funcarg)</span>:</span></span><br><span class="line">		print(<span class="string">"Debug: "</span> + func.__name__ + <span class="string">"..."</span>)</span><br><span class="line">		<span class="keyword">return</span> func(funcarg)</span><br><span class="line">	<span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@debug</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_hello</span><span class="params">(name)</span>:</span></span><br><span class="line">	print(<span class="string">"hello, "</span> + name + <span class="string">"!"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">	say_hello(<span class="string">"qinxue"</span>)</span><br></pre></td></tr></table></figure>
<p>如果需要传递很多参数，那么就将里面的wrapper函数的参数改成统一的、针对任何情况的参数。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug</span><span class="params">(func)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">		print(<span class="string">"Debug: "</span> + func.__name__ + <span class="string">"..."</span>)</span><br><span class="line">		<span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">	<span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@debug</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_hello</span><span class="params">(name, age)</span>:</span></span><br><span class="line">	print(<span class="string">"hello, "</span> + name + <span class="string">"!"</span> + <span class="string">"your age is: "</span> + str(age))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">	say_hello(<span class="string">"qinxue"</span>, <span class="number">24</span>)</span><br></pre></td></tr></table></figure></p>
<p><strong>带参数的装饰器</strong>，这时，就要进行两层封装。第一层为带参数的装饰器函数，第二层为将函数名作为参数的wrapper函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logging</span><span class="params">(level)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(func)</span>:</span></span><br><span class="line">		<span class="function"><span class="keyword">def</span> <span class="title">inner_wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">			print(level + <span class="string">":"</span> + <span class="string">"function: "</span> + func.__name__ + <span class="string">"..."</span>)</span><br><span class="line">			<span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">		<span class="keyword">return</span> inner_wrapper</span><br><span class="line">	<span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@logging(level='INFO')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say</span><span class="params">(something)</span>:</span></span><br><span class="line">    print(<span class="string">"info: "</span> + something)</span><br><span class="line"></span><br><span class="line"><span class="meta">@logging(level='DEBUG')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do</span><span class="params">(something)</span>:</span></span><br><span class="line">    print(<span class="string">"debug: "</span> + something)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">	say(<span class="string">"success!"</span>)</span><br><span class="line">	do(<span class="string">"opps, something wrong!"</span>)</span><br></pre></td></tr></table></figure>
<p>可以这么理解，当带参数的装饰器被打在某个函数上时，比如<code>@logging(level=&#39;DEBUG&#39;)</code>，它其实是一个函数，会马上被执行，只要这个它返回的结果是一个装饰器时，那就没问题。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self)</span>:</span></span><br><span class="line">		print(<span class="string">"I am a student!"</span>)</span><br><span class="line"></span><br><span class="line">s = Student()</span><br><span class="line">s() <span class="comment">#I am a student!</span></span><br></pre></td></tr></table></figure>
<p>这是用类来实现的像<code>__call__</code>这样前后都带下划线的方法在Python中被称为内置方法，有时候也被称为魔法方法。重载这些魔法方法一般会改变对象的内部行为。上面这个例子就让一个类对象拥有了被调用的行为。</p>
<p>回到装饰器上的概念上来，装饰器要求接受一个callable对象。那么用类来实现也是也可以的。可以让类的构造函数<code>__init__()</code>接受一个函数，然后重载<code>__call__()</code>并返回一个函数，也可以达到装饰器函数的效果。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">logging</span><span class="params">(object)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, func)</span>:</span></span><br><span class="line">		self.func = func</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">		print(<span class="string">"debug: "</span> + self.func.__name__)</span><br><span class="line">		<span class="keyword">return</span> self.func(*args, **kwargs)</span><br><span class="line"></span><br><span class="line"><span class="meta">@logging</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">greeting</span><span class="params">(name)</span>:</span></span><br><span class="line">	print(<span class="string">"hello, "</span> + name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">	greeting(<span class="string">"qinxue"</span>)</span><br></pre></td></tr></table></figure>
<p><strong>带参数的类装饰器</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">logging</span><span class="params">(object)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, level=<span class="string">"INFO"</span>)</span>:</span></span><br><span class="line">		self.level = level</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, func)</span>:</span></span><br><span class="line">		<span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">			print(self.level + <span class="string">": func: "</span> + func.__name__)</span><br><span class="line">			func(*args, **kwargs)</span><br><span class="line">		<span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@logging(level="INFO")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">greeting</span><span class="params">(name)</span>:</span></span><br><span class="line">	print(<span class="string">"hello, "</span> + name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">	greeting(<span class="string">"qinxue"</span>)</span><br></pre></td></tr></table></figure>
<p>property是一种特殊的属性，访问它时会执行一段功能（函数）然后返回值。将一个类的函数定义成特性以后，对象再去使用的时候obj.name,根本无法察觉自己的name是执行了一个函数然后计算出来的，这种特性的使用方式<strong>遵循了统一访问的原则</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, radius)</span>:</span> <span class="comment">#圆的半径radius</span></span><br><span class="line">        self.radius = radius</span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">area</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> math.pi * self.radius**<span class="number">2</span> <span class="comment">#计算面积</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">perimeter</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>*math.pi*self.radius <span class="comment">#计算周长</span></span><br><span class="line">	</span><br><span class="line">c = Circle(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">print(c.radius)</span><br><span class="line">print(c.area) <span class="comment">#可以像访问数据属性一样去访问area，会触发一个函数的执行，动态计算出一个值</span></span><br><span class="line">print(c.perimeter) <span class="comment">#同上</span></span><br></pre></td></tr></table></figure>
<p>对于classmethod（类方法）：不管这个方式是从实例调用还是从类调用，它都用第一个参数把类传递过来。具体来说，类和对象都可以调用它。</p>
<p>对于staticmethod（静态方法）：经常有一些跟类有关系的功能但在运行时又不需要实例和类参与的情况下需要用到静态方法<strong>.</strong> 比如更改环境变量或者修改其他类的属性等能用到静态方法。这个其实和C++中的静态函数、静态变量很类似的。同样的，类和对象都可以调用它。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">		self.name = name</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">printName</span><span class="params">(self)</span>:</span></span><br><span class="line">		print(self.name)</span><br><span class="line"></span><br><span class="line"><span class="meta">	@staticmethod</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">smethod</span><span class="params">(*arg)</span>:</span></span><br><span class="line">		print(<span class="string">"Statics: "</span>, arg)</span><br><span class="line"></span><br><span class="line"><span class="meta">	@classmethod</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">cmethod</span><span class="params">(*arg)</span>:</span></span><br><span class="line">		print(<span class="string">"Class: "</span>, arg)</span><br><span class="line"></span><br><span class="line">s = Student(<span class="string">"qinxue"</span>)</span><br><span class="line"></span><br><span class="line">s.printName()<span class="comment"># qinxue</span></span><br><span class="line">Student.printName()<span class="comment"># 会报错，因为类不可以直接调用非静态函数</span></span><br><span class="line"></span><br><span class="line">s.smethod()<span class="comment"># Statics:  ()</span></span><br><span class="line">Student.smethod()<span class="comment"># Statics:  ()</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s.cmethod()<span class="comment"># Class:  (&lt;class '__main__.Student'&gt;,)</span></span><br><span class="line">Student.cmethod()<span class="comment"># Class:  (&lt;class '__main__.Student'&gt;,)</span></span><br></pre></td></tr></table></figure>
<p>当有很多装饰器来装饰一个函数时，其调用过程如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@a</span></span><br><span class="line"><span class="meta">@b</span></span><br><span class="line"><span class="meta">@c</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span></span><br></pre></td></tr></table></figure>
<p>等效于</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f = a(b(c(f)))</span><br></pre></td></tr></table></figure>
<p>示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">from functools import wraps</span><br><span class="line"></span><br><span class="line">def a(func):</span><br><span class="line">	@wraps(func)</span><br><span class="line">	def wrapper(*args, **kwargs):</span><br><span class="line">		print(&quot;a: &quot; + func.__name__ + &quot;...&quot;)</span><br><span class="line">		return func(*args, **kwargs)</span><br><span class="line">	return wrapper</span><br><span class="line"></span><br><span class="line">def b(func):</span><br><span class="line">	@wraps(func)</span><br><span class="line">	def wrapper(*args, **kwargs):</span><br><span class="line">		print(&quot;b: &quot; + func.__name__ + &quot;...&quot;)</span><br><span class="line">		return func(*args, **kwargs)</span><br><span class="line">	return wrapper</span><br><span class="line"></span><br><span class="line">def c(func):</span><br><span class="line">	@wraps(func)</span><br><span class="line">	def wrapper(*args, **kwargs):</span><br><span class="line">		print(&quot;c: &quot; + func.__name__ + &quot;...&quot;)</span><br><span class="line">		return func(*args, **kwargs)</span><br><span class="line">	return wrapper</span><br><span class="line"></span><br><span class="line">@a</span><br><span class="line">@b</span><br><span class="line">@c</span><br><span class="line">def f(name):</span><br><span class="line">	print(&quot;hello, &quot; + name)</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">	f(&quot;qinxue&quot;)</span><br><span class="line"></span><br><span class="line"># 输出的结果为：</span><br><span class="line"># a: f...</span><br><span class="line"># b: f...</span><br><span class="line"># c: f...</span><br><span class="line"># hello, qinxue</span><br></pre></td></tr></table></figure></p>
<p>以上就是对python中装饰器的简单总结。<br>参考文章如下：<br><a href="https://www.zhihu.com/question/26930016" target="_blank" rel="noopener">https://www.zhihu.com/question/26930016</a><br><a href="https://www.cnblogs.com/cicaday/p/python-decorator.html" target="_blank" rel="noopener">https://www.cnblogs.com/cicaday/p/python-decorator.html</a><br><a href="https://www.cnblogs.com/wangyongsong/p/6750454.html" target="_blank" rel="noopener">https://www.cnblogs.com/wangyongsong/p/6750454.html</a><br><a href="https://www.pythoncentral.io/difference-between-staticmethod-and-classmethod-in-python/" target="_blank" rel="noopener">https://www.pythoncentral.io/difference-between-staticmethod-and-classmethod-in-python/</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/19/Python中的装饰器/" data-id="cjov8y3nx00014uniuqakw661" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-计算机网络和操作系统复习" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/02/计算机网络和操作系统复习/" class="article-date">
  <time datetime="2018-03-02T13:38:01.000Z" itemprop="datePublished">2018-03-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/计算机基础/">计算机基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/02/计算机网络和操作系统复习/">计算机网络和操作系统复习</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="计算机网络和操作系统复习"><a href="#计算机网络和操作系统复习" class="headerlink" title="计算机网络和操作系统复习"></a>计算机网络和操作系统复习</h3><p>1.指令周期：读取并执行一条指令所需的时间称为一个指令周期。不同类型的指令其指令周期的长短可以不同，通常，以开始取指令作为一个指令周期的开始，即上一个指令周期的结束。有的CPU设置有专门的取指标志，但一般都不在时序系统中为指令周期设置完整的时间标志信号，因此一般不将指令周期视为时序的一级。<br>而CPU工作周期，时钟周期（节拍），定时脉冲可以视为独立的一级时序。</p>
<p>2.某计算机字长是32位，它的存储容量是256KB，按字编址，它的寻址范围是64K<br>对于按字编址来说一个地址单元有32个基本单元，按双字编址则是一个地址单元有64个，按字节是8个，总容量是256<em>1024</em>8个。所以按字编址的地址数是256<em>1024</em>8/32个，按双字是256<em>1024</em>8/64个，按字节是256<em>1024</em>8/8个。</p>
<p>3.关于多核cpu：<br>多核cpu的主要优势在于处理多任务，处理多任务时性能才能充分发挥出来<br>如果程序是单进程单线程的，多核cpu的处理速度核单核cpu的处理速度理论上是相同的<br>在多核cpu上为了充分利用其性能，程序最好采用多进程多线程异步非阻塞的方式运行</p>
<p>域名组成：主机名.结构名.网络名.最高层域名。<br>一条指令中目的操作数不允许使用的寻址方式是立即数寻址。<br>数据链路层两个重要设备名称：网桥和交换机<br>八进制以0开头,十六进制用0x开头</p>
<p>依赖注入可以降低组件之间的耦合度。而不是增加依赖程度。<br>依赖注入主要有两个好处：<br>(1). 解耦，将依赖之间解耦。<br>(2). 因为已经解耦，所以方便做单元测试，尤其是 Mock 测试。</p>
<p>以太网集线器 - 物理层<br>以太网卡 - 数据链路层<br>路由器-网络层</p>
<p>E-R模型就是实体关系模型、是数据库设计概念设计的任务、<br>而概念设计的下一步就是产生关系模式的逻辑设计、</p>
<p>路由表条目组成：<br>destination 目的网段<br>mask 子网掩码<br>interface 到达该目的地的本路由器的出口ip<br>gateway 下一跳路由器入口的ip，路由器通过interface和gateway定义一调到下一个路由器的链路，通常情况下，interface和gateway是同一网段的<br>metric 跳数，该条路由记录的质量，一般情况下，如果有多条到达相同目的地的路由记录，路由器会采用metric值小的那条路由</p>
<p>数据库管理系统的主要作用是实现数据的统一管理以及对数据库数据的一切操作。<br>oracle、DB2、sybase、informix（现已被IBM收购）、SQL Server等。SQL Server是微软的，只能在Windows上运行，前面四种都可以在UNIX/Linux上跑，系统性能、安全性、可靠性比SQL Server强得多。 </p>
<p>SAR AX,1是算数右移一位，但首位还是原来的值。<br>8520H=1000010100100000B;右移一位是 1100001010010000B ＝ 0C290H</p>
<p>在计算机科学和语言学中，语法分析（英：Syntacticanalysis，也叫Parsing）是根据某种给定的形式文法对由单词序列（如英语单词序列）构成的输入文本进行分析并确定其语法结构的一种过程。<br>语法分析器（Parser）通常是作为编译器或解释器的组件出现的，它的作用是进行语法检查、并构建由输入的单词组成的数据结构（一般是语法分析树、抽象语法树等层次化的数据结构）。语法分析器通常使用一个独立的词法分析器从输入字符流中分离出一个个的“单词”，并将单词流作为其输入。实际开发中，语法分析器可以手工编写，也可以使用工具（半）自动生成。</p>
<p>N个进程各获得(W-1)个资源，且系统中没有资源剩下时，可能发生死锁。所以满足N×(W-1)≥M的情况即有可能发生死锁。即保证系统不会发生死锁的最小M值为：M=N(W-1)+1。</p>
<p>168.192.33.125/27 subnet mask IP address block can be written as<br>27就是27个1，255。255。255。11100000这就是掩码 255.255.255.224<br>地址块就是你这个IP地址所使用的范围。把125转为二进制 01111101<br>掩码为1的为不变位，变位就是掩码为0的，所以你对下，掩码跟IP地址对下，哪些为变位，哪些为不变位，很明显。011到这里都是不变的，变的就是后面的11101这是变位，。所以地址块就是这里全为0到这些全为1<br>即168.192.33.01100000——-168.192.33.01111111这个范围，转为十进制<br>168.192.33.96—-168.192.33.127<br>96为网络地址。127为广播地址，就这么算了！</p>
<p>netstat命令的功能是显示网络连接、路由表和网络接口信息，可以让用户得知有哪些网络连接正在运作。 使用时如果不带参数，netstat显示活动的 TCP 连接。<br>“ping”命令可以检查网络是否连通，可以很好地帮助我们分析和判定网络故障<br>ipconfig——当使用IPConfig时不带任何参数选项，那么它为每个已经配置了的接口显示IP地址、子网掩码和缺省网关值。<br>nslookup命令用于查询DNS的记录，查看域名解析是否正常，在网络故障的时候用来诊断网络问题。</p>
<p>文件的 逻辑结构 主要有：<br>(1)连续结构 (2)多重结构 (3)转置结构 (4)顺序结构<br>文件的 物理存储 主要有：<br>(1)顺序结构 (2)链接结构 (3)索引结构<br>文件的 目录结构 主要有：<br>(1)一级目录结构 (2)二级目录结构 (3)树形结构 (4)无环图</p>
<p>因为数据库和应用程序均储存在一台计算机上，故为集中式体系结构； 如果数据库存放在服务器上，应用程序存放在客户机上，则为主从式（客户机/服务器式）体系结构； 如果数据库物理上存放在不同的场地，则为分布式体系结构</p>
<p>数据库事务的4个特征是<br>原子性：事务执行情况只能有两种：全部执行，全部不执行（回滚制度）<br>一致性：事务执行前后数据具有一致性<br>隔离性：事务之间不可以相互干扰<br>持续性：事务一旦执行，不可自然逆转。</p>
<p>URI 用字符串标识某一互联网资源，而 URL 表示资源的地点（互联<br>网上所处的位置）。可见 URL 是 URI 的子集。</p>
<p>1.DNS劫持又称域名劫持，是指在劫持的网络范围内拦截域名解析的请求，分析请求的域名，把审查范围以外的请求放行，否则返回假的IP地址或者什么都不做使请求失去响应，其效果就是对特定的网络不能反应或访问的是假网址。</p>
<p>2.以下三种是针对客户端的攻击：<br>cross site script（跨站点脚本）<br>cross site request（跨站点请求）<br>ActiveX buffer overflow（控件缓冲溢出）<br>而sql injection（sql注入）属于对服务器的攻击</p>
<p>3.实现防火墙的主流技术有三种：<br>包过滤技术<br>包过滤是最早使用的一种防火墙技术，包过滤技术工作的地方就是各种基于TCP/IP协议的数据报文进出的通道，它把这两层作为数据监控的对象，对每个数据包的头部、协议、地址、端口、类型等信息进行分析，并与预先设定好的防火墙过滤规则（Filtering Rule）进行核对，一旦发现某个包的某个或多个部分与过滤规则匹配并且条件为“阻止”的时候，这个包就会被丢弃。</p>
<ol start="2">
<li>应用代理技术<br>由于包过滤技术无法提供完善的数据保护措施，而且一些特殊的报文攻击仅仅使用过滤的方法并不能消除危害（如SYN攻击、ICMP洪水等），因此人们需要一种更全面的防火墙保护技术，在这样的需求背景下，采用“应用代理”（Application Proxy）技术的防火墙诞生了。一个完整的代理设备包含一个服务端和客户端，服务端接收来自用户的请求，调用自身的客户端模拟一个基于用户请求的连接到目标服务器，再把目标服务器返回的数据转发给用户，完成一次代理工作过程。<br>3 .状态检测技术<br>这种防火墙技术通过一种被称为“状态监视”的模块，在不影响网络安全正常工作的前提下采用抽取相关数据的方法对网络通信的各个层次实行监测，并根据各种过滤规则作出安全决策。</li>
</ol>
<p>4.NAT是网络地址转换，用于公网和内网IP之间的相互转换</p>
<p>5.一些攻击方法：<br>Vulnerability scan，缺陷/弱点 扫描，Attacker可以扫描目标的漏洞，进行相应攻击。<br>Drive-by downloading，Attacker可以给目标公司员工群发一份邮件，如果不小心点击其中的附件，可能就会运行了恶意程序<br>Brute force，暴力破解。</p>
<p>6.DES其分组长度为64比特，秘钥长度也为64比特（前面的8位为基偶校验位，实际长度为56比特）<br>AES的区块长度固定为128比特，密钥长度则可以是128，192或256比特。<br>BlowFish算法用来加密64Bit长度的字符串，其使用两个“盒”——ungigned long pbox[18]和unsigned long sbox[4*256]。</p>
<p>7.CIH病毒是一种能够破坏计算机系统硬件的恶性病毒。常用的方法有：更改计算机系统时钟，经常使用有效的杀毒软件清除病毒，而以下方法并不能：<br>修改磁盘分区：该病毒会以2048个扇区为单位，从硬盘主引导区开始依次往硬盘中写入垃圾数据，直到硬盘数据被全部破坏为止。<br>修改BIOS设置：某些主板上的Flash Rom中的BIOS信息将被清除。<br>更换硬盘：更换硬盘无法防范。</p>
<p>1.Telnet协议是TCP/IP协议族中的一员，是Internet远程登陆服务的标准协议和主要方式。它为用户提供了在本地计算机上完成远程主机工作的能力。在终端使用者的电脑上使用telnet程序，用它连接到服务器。终端使用者可以在telnet程序中输入命令，这些命令会在服务器上运行，就像直接在服务器的控制台上输入一样。可以在本地就能控制服务器。要开始一个telnet会话，必须输入用户名和密码来登录服务器。Telnet是常用的远程控制Web服务器的方法。</p>
<p>2.TP 是File Transfer Protocol（文件传输协议）的英文简称，而中文简称为“文传协议”。用于Internet上的控制文件的双向传输。</p>
<p>1.Telnet协议是TCP/IP协议族中的一员，是Internet远程登陆服务的标准协议和主要方式。它为用户提供了在本地计算机上完成远程主机工作的能力。在终端使用者的电脑上使用telnet程序，用它连接到服务器。终端使用者可以在telnet程序中输入命令，这些命令会在服务器上运行，就像直接在服务器的控制台上输入一样。可以在本地就能控制服务器。要开始一个telnet会话，必须输入用户名和密码来登录服务器。Telnet是常用的远程控制Web服务器的方法。</p>
<p>2.TP 是File Transfer Protocol（文件传输协议）的英文简称，而中文简称为“文传协议”。用于Internet上的控制文件的双向传输。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/02/计算机网络和操作系统复习/" data-id="cjov8y3oy00144uniho5o4lvh" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-win10+VS2015+CPU-Only安装与配置Caffe" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/07/30/win10+VS2015+CPU-Only安装与配置Caffe/" class="article-date">
  <time datetime="2017-07-30T03:53:50.000Z" itemprop="datePublished">2017-07-30</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/深度学习/">深度学习</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/30/win10+VS2015+CPU-Only安装与配置Caffe/">win10+VS2015+CPU-Only安装与配置Caffe</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="win10-VS2015-CPU-Only安装与配置Caffe"><a href="#win10-VS2015-CPU-Only安装与配置Caffe" class="headerlink" title="win10+VS2015+CPU-Only安装与配置Caffe"></a>win10+VS2015+CPU-Only安装与配置Caffe</h3><p>最近在配Caffe，由于我的电脑显卡不是NVIDIA的，所以用不了cuda，所以只能配置CPU-ONLY的，关于配置的教程网上已经很多了，但是具体每个人遇到的问题不一样，我这边就尽量做一个较完整的总结吧：</p>
<p>首先打开github上的项目<a href="https://github.com/BVLC/caffe/tree/windows/" target="_blank" rel="noopener">Caffe for windows</a>，这里面提供了较为完整的教程（当然里面并没有告诉你有哪些坑…），要想安装好，电脑里面要有这些东西，如下：<br><img src="http://img.blog.csdn.net/20170730110610281?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXhjb252ZXJzZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>我们一点一点分析：</p>
<ol>
<li>首先必须安装好VS2013或者VS2015，这是因为Caffe的底层代码主要是C++。</li>
<li>必须安装好CMake，且版本要&gt;=3.4。关于cmake的下载，<a href="https://cmake.org/download/" target="_blank" rel="noopener">cmake下载</a>，最新的版本已经到了3.9了。已经下好的，可以打开cmd，试一试，如下：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake -version</span><br></pre></td></tr></table></figure>
<p><img src="http://img.blog.csdn.net/20170730111143754?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXhjb252ZXJzZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>这里显示我的cmake版本为3.4，刚好满足最低需求。需要注意的是，<strong>这个cmake必须要已经添加在你的系统路径里面</strong>，因为在后面执行脚本的时候，要能直接使用，检验如下：</p>
<p><img src="http://img.blog.csdn.net/20170730111439650?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXhjb252ZXJzZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>下面的就是可选项了，由于我的不支持gpu，所以3，4两点忽略掉。如果你想在python中使用Caffe，那么就需要安装好python，（推荐使用Anaconda，至于版本，只支持2.7和3.5的，可以在官网上下载对应的，<a href="https://www.continuum.io/downloads" target="_blank" rel="noopener">Anaconda下载</a>），<strong>需要注意的是python也需要在环境变量中</strong>，检查如下：</p>
<p><img src="http://img.blog.csdn.net/20170730112002696?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXhjb252ZXJzZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p><img src="http://img.blog.csdn.net/20170730112211855?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXhjb252ZXJzZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>如果需要在matlab中使用Caffe，就要装好matlab。</p>
<p>所以确保了这些，就可以继续往下走了：</p>
<p><img src="http://img.blog.csdn.net/20170730112254220?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXhjb252ZXJzZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>按照下面的代码执行（根据自己的文件目录，不一定按照它的来）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C:\Projects&gt; git clone https://github.com/BVLC/caffe.git</span><br><span class="line">C:\Projects&gt; cd caffe</span><br><span class="line">C:\Projects\caffe&gt; git checkout windows</span><br><span class="line">C:\Projects\caffe&gt; scripts\build_win.cmd</span><br></pre></td></tr></table></figure>
<p>一般执行到前面3步都没有问题。文件结构大概是这样的：</p>
<p><img src="http://img.blog.csdn.net/20170730112728640?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXhjb252ZXJzZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>我的Caffe路径在<code>E:\DeepLearning\caffe</code>，<strong>这个时候里面还没有build文件夹，这是后面cmake生成的。</strong></p>
<p>接着打开<code>scripts\build_win.cmd</code> 这个文件（比如用Notepad++），更改里面的一些配置（由于没有用到APPVEYOR，所以直接看else后面的）：</p>
<p><img src="http://img.blog.csdn.net/20170730113138368?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXhjb252ZXJzZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>需要改动的主要如下：</p>
<ol>
<li>根据自己的VS版本，改变VS版本号</li>
<li>把Ninja设为0，因为这里不需要用到它</li>
<li>把CPU_ONLY设置为1，因为这里没有用到GPU</li>
<li>根据自己的python版本，改变版本号</li>
</ol>
<p>改完后再执行<code>scripts\build_win.cmd</code>，这时我遇到了这样的问题：<code>Could NOT find PythonInterp (missing: PYTHON_EXECUTABLE) (minimum required is &quot;3.5&quot;)</code> ，我明明配置好了python路径，而且也可以直接在cmd里面运行。搜索了很久，还是没有解决，后来突然看到了这段代码：</p>
<p><img src="http://img.blog.csdn.net/20170730114355493?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXhjb252ZXJzZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述">，</p>
<p>虽然并没有运行，但是它手动写出了python的路径，所以我把它也放到了else那段里面了，如下：</p>
<p><img src="http://img.blog.csdn.net/20170730143042977?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXhjb252ZXJzZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>然后就解决了这个问题，后来再执行<code>scripts\build_win.cmd</code>，发现还是报错，一个名为<code>libraries_v140_x64_py35_1.1.0.tar.bz2</code>的依赖包无法下载成功。于是打开<code>...\caffe\cmake\WindowsDownloadPrebuiltDependencies.cmake</code>文件，看看它的下载地址（后面需要加上具体的路径，比如我的是<code>(https://github.com/willyd/caffe-builder/releases/download/v1.1.0/libraries_v140_x64_py35_1.1.0.tar.bz2</code>）：</p>
<p><img src="http://img.blog.csdn.net/20170730144310501?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXhjb252ZXJzZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p><a href="https://github.com/willyd/caffe-builder/releases/download/v1.1.0/libraries_v140_x64_py35_1.1.0.tar.bz2" target="_blank" rel="noopener">下载地址</a>就是这个。于是手动去这个地址上把包下载下来，当时也是下了很多次，一开始网速都很慢（10KB/s的样子。。）<br>把下载好的文件放在 <code>...(你的c盘当前用户目录)\.caffe\dependencies\download</code> 这个目录。然后打开<code>...\caffe\cmake\WindowsDownloadPrebuiltDependencies.cmake</code>这个文件，把下载部分注释掉（红色圈子里面）：</p>
<p><img src="http://img.blog.csdn.net/20170730145504087?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXhjb252ZXJzZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>并且打开<code>...\caffe\scripts\download_prebuilt_dependencies.py</code>文件，注释掉下载部分：</p>
<p><img src="http://img.blog.csdn.net/20170730145642735?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXhjb252ZXJzZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>接着再运行<code>build_win.cmd</code>，就可以顺利进行了，它会把刚刚下载的那个压缩包解压，然后慢慢编译。。。</p>
<p><img src="http://img.blog.csdn.net/20170730143231598?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXhjb252ZXJzZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>大概用来7分多钟，就完成了：</p>
<p><img src="http://img.blog.csdn.net/20170730145849547?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXhjb252ZXJzZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>看到这一幕的我开心地笑了。。。折腾了一天，终于配置得差不多了。于是又开始配置python接口：</p>
<p><img src="http://img.blog.csdn.net/20170730150253144?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXhjb252ZXJzZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>这里的坑倒不是很多，因为安装了Anaconda，安装包特别方便（当然还是要看网速的心情了），但是有些是不用装的，比如cmake，ninja，graphviz，按照上面的图来就ok了。最后就可以在python的环境中导入caffe了！</p>
<p><img src="http://img.blog.csdn.net/20170730153043179?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXhjb252ZXJzZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>关于mnist的测试下一次讲。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/07/30/win10+VS2015+CPU-Only安装与配置Caffe/" data-id="cjov8y3om000j4uniryy1q5zx" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-深度学习中Dropout浅析" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/10/深度学习中Dropout浅析/" class="article-date">
  <time datetime="2017-03-10T09:48:55.000Z" itemprop="datePublished">2017-03-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/深度学习/">深度学习</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/10/深度学习中Dropout浅析/">深度学习中Dropout浅析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>关于Dropout这个概念，之前在学习深度学习的那本花书中遇到过，在项目中通过Caffe、Keras也用过，但是没有仔细研究过它是做什么的，而仅仅是拿过来用，最近看了一些相关的博客，想总结一下。</p>
<p>Dropout的作用是为了防止过拟合的，特别是当训练集数据量较小的时候，这就会导致其泛化能力大大下降。而加上Dropout的操作，其作用是让某些神经元失去作用，即在每次训练的时候，每个神经元有一定的几率被移除。</p>
<p>其实，Dropout可以被认为是集成大量深层神经网络的实用Bagging方法。Bagging涉及训练多个模型，并在每个测试样本上评估多个模型。当每个模型都是一个很大的神经网络时，这似乎是不切实际的，因为训练和评估这样的网络需要花费很多运行时间和内存。Dropout提供了一种廉价的Bagging集成近似，能够训练和评估指数级数量的神经网络。</p>
<p>它所做的就是在训练过程中集成包括所有从基础网络除去非输出单元后形成的子网络。简单一点的是乘零操作，即将一些单元的输出乘零就能有效地删除一个单元。而有些框架的实现就是如此。比如keras。</p>
<p><img src="http://img.blog.csdn.net/20180310165212885?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXhjb252ZXJzZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>回想一下Bagging学习，我们定义$k$个不同的模型，从训练集有替换采样构造$k$个不同的数据集，然后在训练集$i$上训练模型$i$。Dropout的目标是在指数级数量的神经网络上近似这个过程。具体来说，在训练中使用Dropout时，我们会使用基于小批量的学习算法和较小的步长，如梯度下降等。我们每次在小批量中加载一个样本，然后随机抽样应用于网络中所有输入和隐藏单元的不同二值掩码。对于每个单元，掩码是独立采样的。掩码值为1 的采样概率（导致包含一个单元）是训练开始前一个固定的超参数。其实这个就是dropout的参数，其取值范围为$[0,1]$.</p>
<p>以下是keras中关于dropout的函数实现，其实它使用随机数生成器生成0，1的向量，然后分别乘上该神经元的值。最后需要注意的是每个值还需要除以（1-level）的概率。其中level即是dropout的参数（以[0,1]之间某个值作为丢弃概率的参数）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">def dropout(x, level, noise_shape=None, seed=None):</span><br><span class="line">    &quot;&quot;&quot;Sets entries in `x` to zero at random,</span><br><span class="line">    while scaling the entire tensor.</span><br><span class="line"></span><br><span class="line">    # Arguments</span><br><span class="line">        x: tensor</span><br><span class="line">        level: fraction of the entries in the tensor</span><br><span class="line">            that will be set to 0.</span><br><span class="line">        noise_shape: shape for randomly generated keep/drop flags,</span><br><span class="line">            must be broadcastable to the shape of `x`</span><br><span class="line">        seed: random seed to ensure determinism.</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    if level &lt; 0. or level &gt;= 1:</span><br><span class="line">        raise ValueError(&apos;Dropout level must be in interval [0, 1[.&apos;)</span><br><span class="line">    if seed is None:</span><br><span class="line">        seed = np.random.randint(1, 10e6)</span><br><span class="line">    if isinstance(noise_shape, list):</span><br><span class="line">        noise_shape = tuple(noise_shape)</span><br><span class="line"></span><br><span class="line">    rng = RandomStreams(seed=seed)</span><br><span class="line">    retain_prob = 1. - level</span><br><span class="line"></span><br><span class="line">    if noise_shape is None:</span><br><span class="line">        random_tensor = rng.binomial(x.shape, p=retain_prob, dtype=x.dtype)</span><br><span class="line">    else:</span><br><span class="line">        random_tensor = rng.binomial(noise_shape, p=retain_prob, dtype=x.dtype)</span><br><span class="line">        random_tensor = T.patternbroadcast(random_tensor,</span><br><span class="line">                                           [dim == 1 for dim in noise_shape])</span><br><span class="line">    x *= random_tensor</span><br><span class="line">    x /= retain_prob</span><br><span class="line">    return x</span><br></pre></td></tr></table></figure>
<p>至于为什么要除以那个值，<a href="http://blog.csdn.net/hjimce/article/details/50413257" target="_blank" rel="noopener">可以查看这篇博客的解释。</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/03/10/深度学习中Dropout浅析/" data-id="cjov8y3ov000x4uniwvf0atoa" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/C/">C++</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CV/">CV</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/分布式系统/">分布式系统</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据结构与算法/">数据结构与算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/深度学习/">深度学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法与数据结构/">算法与数据结构</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机基础/">计算机基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/面试/">面试</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">July 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">March 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/11/">November 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/10/">October 2015</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/11/24/设计模式相关/">(no title)</a>
          </li>
        
          <li>
            <a href="/2018/11/24/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2018/04/14/leetcode(1-100)/">leetcode代码(1-100)</a>
          </li>
        
          <li>
            <a href="/2018/04/14/leetcode(101-200)/">leetcode代码(101-200)</a>
          </li>
        
          <li>
            <a href="/2018/04/14/leetcode(201-300)/">leetcode代码(201-300)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 qinxue<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>